//go:build js && wasm && client

/*
	Code generated by agrows. DO NOT EDIT :)
	This code was generated on 2024-07-16 at 22:11:54
	Any changes made to this file will be lost
*/
package main

import (
	"encoding/json"
	"fmt"
	protocol "github.com/codeupdateandmodificationsystem/protocol"
	"reflect"
	js "syscall/js"
)

type CalcInput struct {
	A int
	B int
}

func jsValueToAny(v js.Value, targetType reflect.Type) (any, any) {
	switch v.Type() {
	case js.TypeBoolean:
		return v.Bool(), nil
	case js.TypeNumber:
		switch targetType.Kind() {
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			return int(v.Int()), nil
		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
			return uint(v.Int()), nil
		case reflect.Float32, reflect.Float64:
			return v.Float(), nil
		default:
			return v.Float(), nil
		}
	case js.TypeString:
		return v.String(), nil
	case js.TypeObject:
		result := make(map[string]any)
		keys := js.Global().Get("Object").Call("keys", v)
		for i := 0; i < keys.Length(); i++ {
			key := keys.Index(i).String()
			value, err := jsValueToAny(v.Get(key), reflect.TypeOf((*any)(nil)).Elem())
			if err != nil {
				return nil, err
			}
			result[key] = value
		}
		jsonData, err := json.Marshal(result)
		if err != nil {
			return nil, js.Global().Get("Error").New(fmt.Sprintf("failed to marshal js object to json: %v", err))
		}
		targetValue := reflect.New(targetType).Interface()
		err = json.Unmarshal(jsonData, targetValue)
		if err != nil {
			return nil, js.Global().Get("Error").New(fmt.Sprintf("failed to unmarshal json to target type: %v", err))
		}
		return reflect.ValueOf(targetValue).Elem().Interface(), nil
	case js.TypeFunction:
		return v, nil
	case js.TypeUndefined, js.TypeNull:
		return nil, nil
	default:
		return nil, js.Global().Get("Error").New(fmt.Sprintf("unsupported js value type: %s", v.Type()))
	}
}

func SayHello(name string) any {
	data, err := protocol.EncodeFunctionCall("SayHello", protocol.Options(), map[string]any{
		"name": name,
	})
	if err != nil {
		return err
	}
	return sendMessage(data)
}
func SayHelloWrapper(this js.Value, p []js.Value) any {
	if len(p) != 1 {
		return js.Global().Get("Error").New(fmt.Sprintf("expected 1 arguments, got %d", len(p)))
	}
	nameAsAny, err := jsValueToAny(p[0], reflect.TypeOf((*string)(nil)).Elem())
	if err != nil {
		return js.Global().Get("Error").New(fmt.Sprintf("failed to make go type 'string' from js value: %+v", err))
	}
	name, ok := nameAsAny.(string)
	if !ok {
		return js.Global().Get("Error").New(fmt.Sprintf("parameter 'name' is not in the received arguments"))
	}
	return SayHello(name)
}

func CrazyMath(inp CalcInput) any {
	data, err := protocol.EncodeFunctionCall("CrazyMath", protocol.Options(), map[string]any{
		"inp": inp,
	})
	if err != nil {
		return err
	}
	return sendMessage(data)
}
func CrazyMathWrapper(this js.Value, p []js.Value) any {
	if len(p) != 1 {
		return js.Global().Get("Error").New(fmt.Sprintf("expected 1 arguments, got %d", len(p)))
	}
	inpAsAny, err := jsValueToAny(p[0], reflect.TypeOf((*CalcInput)(nil)).Elem())
	if err != nil {
		return js.Global().Get("Error").New(fmt.Sprintf("failed to make go type 'CalcInput' from js value: %+v", err))
	}
	inp, ok := inpAsAny.(CalcInput)
	if !ok {
		return js.Global().Get("Error").New(fmt.Sprintf("parameter 'inp' is not in the received arguments"))
	}
	return CrazyMath(inp)
}

func sendMessage(data []byte) any {
	jsGlobal := js.Global()
	sendMessageFunc := jsGlobal.Get("sendMessage")
	if sendMessageFunc.Type() != js.TypeFunction {
		return js.Global().Get("Error").New("sendMessage is not a JS function")
	}
	uint8Array := js.Global().Get("Uint8Array").New(len(data))
	js.CopyBytesToJS(uint8Array, data)
	sendMessageFunc.Invoke(uint8Array)
	return nil
}

func main() {
	global := js.Global()
	global.Set("SayHello", js.FuncOf(SayHelloWrapper))
	global.Set("CrazyMath", js.FuncOf(CrazyMathWrapper))

	select {}
}
